package edu.globant.day3.multithreading.exercices;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.Set;

public class BankingCenter {
	
	public static void main(String[] args) throws InterruptedException {
		
		Queue<Customer> queue = new LinkedList<Customer>(); //queue where new customers will be waiting and from where tellers will retrieve them
		Set<Thread> tellers = new HashSet<Thread>(); //Set of threads, simulating tellers
		
		Random random = new Random();
		
		Thread enqueuer = new Thread(() -> {  //Thread which will enque the new customers, simulating their arrival to the bank
			int i=1;
			while(true){
				try {  //we add it some delay so not to add lots of customers all the time
					Thread.sleep((random.nextInt(4)+1)*200);
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				if(!(queue.size()>5)){  //WE ESTABLISH THAT THE MAXIMUM OF CUSTOMERS THAT CAN BE WAITING IS 5; OTHERWISE, THE NEW CUSTOMER MUST WAIT TILL SOME CUSTOMER IS ATTENDED
					int nextRandom = random.nextInt(3)+1; 
					String typeOfCustomer = "check";
					switch(nextRandom){ //the type of action which the client will make (each one has its duration/cost) is generated by a new random
						case 1:
							typeOfCustomer="borrow";
							break;
						case 2:
							typeOfCustomer="deposit";
							break;
						default:
							break;
					}
					queue.offer(new Customer(String.valueOf(i),typeOfCustomer));
					System.out.println("Client "+String.valueOf(i)+" is now at the queue, wanting to "+typeOfCustomer);
					i++;
				} else System.out.println("¡¡¡ATENTION!!! Clients outside waiting the queue to be smaller so they can enter it!!"+queue);
			}
		});
		
		int numberOfTellers = random.nextInt(4)+1; //in each running of the program, a different amount of tellers will be available (a random number between 1-4)
		for (int i = 0; i < numberOfTellers; i++) {
			Thread teller = new Thread(() -> {  //Thread that simulates a teller
				Customer nextToAttend;
				while(true){
					nextToAttend=null;
					synchronized (queue) { //we sync the acces to the queue of customers, avoiding problems
						if(queue.size()>0){
							nextToAttend = queue.poll();
						}
					}
					if(nextToAttend!=null){  //if there was somebody at the queue, the teller attends him/her
						System.out.println("---"+String.format(Thread.currentThread().getName()+" attending client "+nextToAttend.getName()+", "
								+ "who wants to "+nextToAttend.getBankAction()));
						nextToAttend.makeAction();
					}
				}
			}, "Teller no "+(i+1));
			tellers.add(teller);
		}
		
		
		System.out.println("Opening bank"); //The bank is opened
		tellers.stream().forEach(t->{	//Tellers are ready to attend customers
			t.setDaemon(true);  //So when the bank is closed, tellers cannot attend more customers
			t.start();
		});
		enqueuer.setDaemon(true);  //So when the bank is closed, customers cant enter the bank anymore
		enqueuer.start();  //Customers are now entering the bank
		Thread.sleep(20000); //Simulating the schedule of the bank
		System.out.println("Bank Closed");  //The bank is closed
		System.out.println(queue+" have priority for tomorrow, since they got to enter the bank and got a number");
	}

	
}
