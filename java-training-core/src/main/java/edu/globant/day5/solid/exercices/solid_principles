1) Single Responsibility Principle
This principle may be applied in most of the applications, since developers tend to group lots of functionalities together, not respecting this principle
nor the "low coupling" one. We could apply it in validations, where we validate an email for example, validating it's not null, it has an email format, etc;
what we could do is to decouple that function to a Email class, which would have a method such as validateEmail(String email).
2) Open/Close principle
There are many cases in which we tend to design an algorithm only thinking in the current situation of the problem; a few days after that moment, a new 
situation suddenly appear, and we have to modify it so it satisfies both the previous situation plus the new one; and this is repeated every now and then,
making such a big mess in the algorithm that a giant if/else condition is created; so, thinking about this principle from the word go is a great deal.
3) Liskov Substitution Principle
This principle, as we saw at the class, can also be seen in java default classes, like stack and vector. It usually happen that we create a hierarchy, and then
we notice that a subclass is inheriting some behavior from its superclass that not corresponds; this leads us to invoke that method in a subclass, which will
generate an exception (controlled, in the best case) or result in a non-desired action. In this case, we should rethink the hierarchy, or see how to implement
the method in the subclass so that it behaves as the client would expect.